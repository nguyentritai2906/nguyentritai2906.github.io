[{"content":"Linear Regression is the most basic, well known and well understood supervised learning algorithm. It\u0026rsquo;s probably the first thing that every Machine Learning Engineer and Data Scientist come across as it lays the foundation for other sophisticated learning algorithm. But what is it?\nWhat is Linear Regression? Before knowing what is linear regression, let us get ourselves accustomed to regression. Regression is a method of modeling the relationships between a dependent variable and one or more independent variables.\nIt is used when we want to predict the value of a variable based on the value of other variables. The variable we want to predict is called the dependent variable (also called the target or output). The variables we are using to predict the another variable\u0026rsquo;s value are called the independent variables (also called the features or input). Regression techniques mostly differ based on the number of independent variables and the type of relationship between the dependent and independent variables.\nLinear regression is a linear model, i.e. a model that assumes a linear relationship between the input variables $x$ and the single output variable $y$. More specifically, that $y$ can be calculated from a linear combination of the input variables. When there is a single input variable, the method is referred to as simple linear regression. When there are multiple input variables, literature from statistics often refers to the method as multiple linear regression.\nIn machine learning, linear regression is a supervised learning algorithm where the predicted output is continuous and has a constant slope. It’s used to for forecasting and finding out cause and effect relationship between variables within a continuous range (e.g. sales, price).\n  Linear Regression In Real Life \u0026ndash; by Carolina Bento\n  Linear Regression Model Representation Linear regression model is an attractive model because the representation is so simple. It\u0026rsquo;s just a function of one or more input feature $x$ and an output value $y$. As such, both the input and output value are numeric.\nMore generally, a linear model make prediction by simply computing a weighted sum of the input values plus a constant called the bias term (also called the intercept term), as shown in the equation below:\n$$y = \\theta_0 + \\theta_1 x_1 + \\theta_2 x_2 + \u0026hellip; + \\theta_n x_n$$\nIn this equation:\n $y$ is the predicted value. $n$ is the number of features. $x_i$ is the $i^{th}$ feature value. $\\theta_j$ (pronounced theta) is the $j^{th}$ model parameter (including the bias term $\\theta_0$ and the feature weights $\\theta_1$, $\\theta_2$, \u0026hellip;, $\\theta_n$).  This can be written more concisely using a vectorized form as:\n$$y = h_{\\bm\\theta}\\left(\\textbf{x}\\right) = \\bm\\theta^T\\cdot\\textbf{x}$$\nWhere:\n $\\bm\\theta^T$ is the transpose of the model\u0026rsquo;s parameter vector, containing the bias term $\\theta_0$ and the feature weights $\\theta_1$ to $\\theta_n$. $\\textbf{x}$ is the instance\u0026rsquo;s feature vector, containing $x_0$ to $x_n$, with $x_0$ always equal to 1. $\\bm\\theta^T \\cdot \\textbf{x} $ is the dot product of the vectors $\\bm\\theta^T$ and $\\textbf{x}$. $h_{\\bm\\theta}$ is the hypothesis function, using the model parameters $\\theta$.  Our job is to set its parameters (i.e. find $\\bm\\theta$) so that the model best fits the training set. For this purpose we need some metric to measure how well (or poorly) the model fits the training data.\nThe Cost Function Mean Squared Error The most common performance measure of a regression model is the Root Mean Squared Error (RMSE). But in some contexts you may prefer to use another function, e.g. Mean Absolute Error (MAE) if there are many outliers. Here we\u0026rsquo;ll use the Mean Squared Error (MSE) because it is simplier to minimize than the RMSE, and it lead to the same result (because it value that minimizes this function also minimizes its square root).\nThe MSE of a Linear Regression hypothesis $h_{\\bm\\theta}$ on a training set $\\textbf{X}$ (also called the cost function) is calculated using the equation:\n$$ \\text{MSE}\\left(\\textbf{X}, h_{\\bm\\theta}\\right) = \\frac{1}{m} \\displaystyle\\sum_{i=1}^m \\left(\\bm\\theta^T \\textbf x^{(i)} - y^{(i)}\\right)^2 $$\nWhere:\n $m$ is the number of instances in the dataset you are measuring on. $\\bm\\theta^T \\textbf x^{(i)}$ is the predicted value of the model for the $i^{th}$ instance. $y^{(i)}$ is the target value of the $i^{th}$ instance. $\\textbf x^{(i)}$ is a vector of all the feature values $\\textbf{X}$ is a matrix containing all the feature values of all instances in the dataset. There is one instance per row, and the $i^{th}$ row is equal to the transpose of all the features of this instance $\\textbf{x}^{(i)}$ $h_{\\bm\\theta}$ is the model\u0026rsquo;s prediction function parameterized by the vector $\\theta$, also called the hypothesis.  What it does is calculate the difference between the model\u0026rsquo;s prediction and the true target value and square it (hence $\\left(\\bm\\theta^T \\textbf x^{(i)} - y^{(i)}\\right)^2$). Do it for all of the instances in the dataset then take the sum of all the calculated square differences. Divide that sum by the total number of instances in the dataset to get the mean. The larger the error, the larger the MSE and the opposite. We want to find the value of $\\bm\\theta$ to minimize the MSE.\nThe Normal Equation To find the value of $\\bm\\theta$ that minimizes the cost function, there is a closed-form solution - in other words, a mathematical equation that gives the result directly.\nLet us representing the cost function in a vector form, starting with the residual\n$$ \\begin{bmatrix} \\theta^T({x}^0)\\newline \\theta^T({x}^1)\\newline \\vdots \\newline \\theta^T({x}^m)\\newline \\end{bmatrix} - \\begin{bmatrix} y^0\\newline y^1\\newline \\vdots \\newline y^m\\newline \\end{bmatrix} = \\textbf{X} \\bm\\theta - y $$\nBut each residual value is squared. We can not simply square the above expression. As the square of a vector/matix is not equal to the square of each of its values. So to get the squared value, multiply the vector/matrix with its transpose. Therefore the final equation is:\n$$ \\text{MSE}\\left(\\textbf{X}, h_{\\bm\\theta}\\right) = \\frac{1}{m}\\left(\\left(\\textbf{X} \\bm\\theta - y\\right)^T \\left(\\textbf{X} \\bm\\theta - y\\right)\\right) \\newline = \\frac{1}{m}\\left(\\left(\\textbf{X}\\bm\\theta\\right)^T\\textbf{X}\\bm\\theta - y\\left(\\textbf{X}\\bm\\theta\\right)^T - y^T\\textbf{X}\\bm\\theta + y^Ty\\right) \\newline = \\frac{1}{m}\\left(\\bm\\theta^T \\textbf{X}^T \\textbf{X} \\bm\\theta - 2 \\bm\\theta^T \\textbf{X}^T y + y^Ty\\right) $$\nNow to minimize $\\text{MSE}\\left(\\textbf{X}, h_{\\bm\\theta}\\right)$ w.r.t. $\\theta$ we\u0026rsquo;ll set its derivative equal to 0 (i.e., implying that we have a local optimum of the error, it would be the best fit line for the dataset) and solve for $\\theta$. But how do we differentiate this?\nOk, here are the two useful identities we\u0026rsquo;ll need:\n Derivative of a linear function:  $$ \\frac{\\partial}{\\partial\\vec{x}}\\vec{a} \\cdot \\vec{x} = \\frac{\\partial}{\\partial\\vec{x}}\\vec{a}^T \\vec{x} = \\frac{\\partial}{\\partial\\vec{x}}\\vec{x}^T \\vec{a} = \\vec{a} $$\n(If you think back to calculus, this is just $\\frac{d}{dx}ax = a$)\n Derivative of a quadratic function: if A is symmetric, then:  $$ \\frac{\\partial}{\\partial\\vec{x}} \\vec{x}^T A \\vec{x} = 2 A \\vec{x} $$\n(Again, thinking back to calculus, this is just like $\\frac{d}{dx}ax^2 = 2ax$)\nIn case you\u0026rsquo;re wondering what if A is non-symmetric. The more general rule is:\n$$ \\frac{\\partial}{\\partial\\vec{x}} \\vec{x}^T A \\vec{x} = \\left(A + A^T\\right) \\vec{x} $$\nWhich of course is the same thing as $2A\\vec{x}$ when $A$ is symmetric.\nNow back at the cost function, we can see that it\u0026rsquo;s derivative w.r.t. $\\bm\\theta$ noted as $\\nabla_\\theta MSE(\\bm\\theta)$ (also called the gradient vector) is just:\n$$ \\nabla_\\theta MSE(\\bm\\theta) = \\frac{2}{m} \\left(\\textbf{X}^T\\textbf{X}\\bm\\theta - \\textbf{X}^Ty\\right) $$\nLet\u0026rsquo;s set it equal to 0 (noted as $\\stackrel{!}{=}$, think of it as \u0026ldquo;shall be (made) equal to\u0026rdquo;) and solve for $\\bm\\theta$\n$$ \\nabla_\\theta MSE(\\bm\\theta) = \\frac{2}{m} \\left(\\textbf{X}^T\\textbf{X}\\bm\\theta - \\textbf{X}^Ty\\right) \\stackrel{!}{=} 0 \\newline \\implies \\textbf{X}^T\\textbf{X}\\bm\\theta = \\textbf{X}^Ty \\newline \\implies \\bm\\theta = (\\textbf{X}^T \\textbf{X})^{-1} \\ \\ \\textbf{X}^T \\ \\ y $$\nThis is called the Normal Equation:\n$$ \\widehat{\\bm\\theta} = (\\textbf X^T \\textbf X )^{-1} \\ \\ \\textbf X^T \\ \\ y $$\nIn this equation:\n $\\widehat{\\bm\\theta}$ is the value of $\\bm\\theta$ that minimizes the cost function. $y$ is the vector of target values containing $y^{(1)}$ to $y^{(m)}$  Let\u0026rsquo;s generate some random linear-looking data to this equation.\nimport numpy as np X = 2 * np.random.rand(100, 1) y = 5 + 4 * X + np.random.randn(100, 1) Now let compute $\\widehat{\\bm\\theta}$ using the Normal Equation. We\u0026rsquo;ll use the np.linalg.inv() function from NumPy\u0026rsquo;s linear algebra module to compute the inverse of a matrix. Note that the @ symbol was introduced in Python 3.5 as matrix multiplication.\nX_b = np.c_[np.ones((100,1)), X] theta_bestfit = np.linalg.inv(X_b.T @ X_b) @ X_b.T @ y The function we used to generate the data is $y = 5 + 4x_1$ with some Gaussian noise. Let\u0026rsquo;s see what the equation found!\n\u0026gt;\u0026gt;\u0026gt; theta_bestfit array([[5.09647054], [4.01624421]]) Close enough. The noise made it impossible to recover the exact parameters of the original function. Now we can make prediction using $\\widehat{\\bm\\theta}$\nX_test = np.array([[0], [3]]) X_test_b = np.c_[np.ones((2,1)), X_test] y_predict = X_test_b @ theta_bestfit \u0026gt;\u0026gt;\u0026gt; y_predict array([[ 5.09647054], [17.14520317]]) But the Normal Equation may not work if the matrix $\\bm{X}^T\\bm{X}$ is not invertible (i.e. singular also called degenerate). This equation has a single solution if $\\bm{X}^T\\bm{X}$ is invertible (i.e. non-singular). If it\u0026rsquo;s not, you have more solutions.\nTake $\\textbf{X} = \\begin{bmatrix} 1 \u0026amp; 0 \\newline 0 \u0026amp; 1 \\newline 0 \u0026amp; 0 \\end{bmatrix}$ for example, it\u0026rsquo;s transpose will be $\\textbf{X}^T = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\newline 0 \u0026amp; 1 \u0026amp; 0 \\end{bmatrix} $. Therefore\n$$ \\textbf{X}^T \\textbf{X} = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\newline 0 \u0026amp; 1 \u0026amp; 0 \\newline 0 \u0026amp; 0 \u0026amp; 0 \\end{bmatrix} $$\nWe can see that the determinant of this matrix 0 so it is not invertible. Then how can we solve for $\\bm\\theta$? Use the Moore-Penrose inverse!\nThe Moore-Penrose Pseudoinverse In Linear Algebra, the Moore-Penrose inverse of a matrix is the most well known generalization of the inverse matrix. The term generalized inverse is sometimes used as a synonym for pseudoinverse. A common use of the pseudoinverse is to compute a \u0026ldquo;best fit\u0026rdquo; (least square) solution to a system of linear equations that lacks a solution. Another is to find the minimum (Euclidean) norm solution to a system of linear equations with multiple solutions. That\u0026rsquo;s exactly what we need.\nThe pseudoinverse itself is computed using a standard matrix factorization technique called Singular Value Decomposition (SVD) that can decompose any matrix $\\textbf X$ into the matrix multiplication of three matrices.\n$$ \\textbf{X} = \\textbf{U} \\Sigma \\textbf{V}^T $$\nWhere $\\textbf{U}$ and $\\textbf{V}$ are orthogonal matrices (i.e. its inverse equal to its transpose), $\\Sigma$ is a diagonal matrix (i.e. entries out side the main diagonal are zeros).\nWhat does it actually do? You might ask. I\u0026rsquo;ll save it for another post. It\u0026rsquo;s deserve a post of its own. Now let\u0026rsquo;s suppose $\\textbf X$ is invertible, then its inverse is\n$$ \\textbf X^{-1} = \\textbf V \\Sigma^{-1} \\textbf U^T $$\nThe pseudoinverse of $\\textbf{X}$ is quite similar but instead of $\\Sigma^{-1}$ we use it\u0026rsquo;s pseudoinverse $\\Sigma^+$\n$$ \\textbf{X}^+ = \\textbf{V} \\Sigma^+ \\textbf{U}^T $$\nWhere $\\Sigma^+$ is computed by replace all nonzero values with their inverse and transpose the resulting matrix.\nNow let\u0026rsquo;s take our linear model equation above and rewrite it in its matrix form as:\n$$ \\textbf{X} \\bm\\theta = y $$\nWe know that inverse of a matrix multiply by itself is equal to the identity matrix and any matrix multiply by the identity matrix result in the matrix itself. Hence\n$$ \\textbf{X}^+ \\textbf{X} \\bm\\theta = \\textbf{X}^+ y \\newline \\implies \\bm\\theta = \\textbf{X}^+ y $$\nSee something similar? That\u0026rsquo;s right, it looks like our Normal Equation above. It implies that\n$$ \\textbf{X}^+ = \\textbf{V} \\Sigma^+ \\textbf{U}^T = (\\textbf X^T \\textbf X )^{-1} \\ \\ \\textbf X^T $$\nIndeed, if we multiply the left and right side of the equation to $\\textbf{X}$ we\u0026rsquo;ll get back the identity matrix\n$$ \\textbf{X}^+ \\textbf{X} = (\\textbf X^T \\textbf X)^{-1} \\ \\ \\textbf X^T \\textbf{X} = \\textbf I $$\nOr if we take the right hand side of the equation, plug in the SVD and cancel like crazy we\u0026rsquo;ll get\n$$ (\\textbf X^T \\textbf X)^{-1} \\ \\ \\textbf X^T \\newline = (\\textbf U^T \\Sigma \\textbf V \\ \\textbf U \\Sigma \\textbf V^T)^{-1} \\ \\textbf U^T \\Sigma \\textbf V \\newline = \\textbf V \\Sigma^+ \\textbf U^T \\ \\textbf V^T \\Sigma^+ \\textbf U \\ \\textbf U^T \\Sigma \\textbf V \\newline = \\textbf V \\Sigma^+ \\textbf U^T $$\nThis approach is more efficient than computing the Normal Equation, plus it handles edge cases nicely and the pseudoinverse is always defined.\nPerforming Moore-Penrose Pseudoinverse in python is simple. Just call np.linalg.pinv() instead!\ntheta_pinv = np.linalg.pinv(X_b) @ y \u0026gt;\u0026gt;\u0026gt; theta_pinv array([[5.09647054], [4.01624421]]) Computational Complexity The Normal Equation computes the inverse of $\\textbf{X}^T \\textbf X$, which is an $(n + 1) \\times (n + 1)$ matrix (where $n$ is the number of features). The computational complexity of inverting such an matrix is typically about $O(n^{2.4})$ to $O(n^3)$, depending on the implementation. In other words, if you double the number of features, you multiply the computational time by roughly $2^{2.4} = 5.3$ to $2^3 = 8$.\nThe SVD approach used by Scikit-Learn\u0026rsquo;s LinearRegression class is about $O(n^2)$. If you double the number of features, you multiply the computational time by roughly 4.\nWhat it means is both the Normal Equation and the SVD approach get very slow when the number of features grows large (e.g. 100,000). On the positive side, both are linear with regard to the number of instances in the training set (they are $O(m)$), so they handle large training sets efficiently, provided they can fit in memory.\nAlso, once you have trained your Linear Regression model (using the Normal Equation or any other algorithm), predictions are very fast: the computational complexity is linear with regard to both the number of instances you want to make predictions on and the number of features. In other words, making predictions on twice as many instances (or twice as many features) will take roughly twice as much time.\nNow we\u0026rsquo;ll look at a very different way to train a Linear Regression model, which is better suited for cases where there are a large number of features or too many training instances to fit in memory.\nGradient Descent Gradient Descent is a generic optimization algorithm capable of finding optimal solutions to a wide range of problems. The general idea of Gradient Descent is to tweak parameters iteratively in order to minimize a cost function. It measures the local gradient of the error function with regard to the parameter vector $\\theta$, and it goes in the direction of descending gradient. Once the gradient is zero, you have reached a minimum!\nGenerally you start by defining $\\theta$ with random values (this is called random initialization). Then you improve it gradually, taking one baby step at a time, each step attempting to decrease the cost function (e.g. the MSE), until the algorithm converges to a minimum.\nAn important parameter in Gradient Descent is the size of the step, determined by the learning rate hyperparameter. If the learning rate is too small, then the algorithm will have to go through many iterations to converges, which will take a long time.\nOn the other hand, if the learning rate is too high, you might over shoot the local minimum, possibly even higher error than you were before. This might make the algorithm diverge, with larger and larger values, failing to find a good solution.\nFinally, not all cost functions looks like nice, regular bowls. There may be holes, ridges plateaus, and all sort of irregular terrains, making convergence to the minimum difficult.\nFortunately, the MSE cost function for a Linear Regression model happens to be a convex function, which means that if you pick any two points on the curve, the line segment join them never crosses the curve. This implies that there are no local minima, just one global minimum. It is also a continuous function with a slope that never changes abruptly. These two facts have a great consequence: Gradient Descent is guaranteed to approach arbitrary close the global minimum.\nTo implement Gradient Descent, you need to compute the gradient of the cost function with regard to each model parameter $\\theta_j$. In other words, you need to calculate how much the cost function will change if you change $\\theta_j$ just a little bit. This is called the partial derivative. It is like asking \u0026ldquo;If I take one small step ahead, which way is downhill?\u0026rdquo;. The equation to computes the partial derivative of the cost function with regard to parameter $\\theta_j$ noted $\\frac{\\partial}{\\partial\\theta_j}MSE(\\bm\\theta)$ is\n$$ \\frac{\\partial}{\\partial\\theta_j}MSE(\\bm\\theta)\\ = \\frac{2}{m} \\sum_{i=1}^m (\\bm\\theta^T \\textbf{x}^{(i)} - y^{(i)})x_j^{(i)} $$\nInstead of computing these partial derivatives individually, you can use the equation below (just like we\u0026rsquo;ve worked it out above for the Normal Equation) to compute them all in one go. The gradient vector, noted $\\nabla_\\theta MSE(\\bm\\theta)$, contains all the partial derivatives of the cost function (one for each model parameter).\n$$ \\nabla_\\theta MSE(\\bm\\theta) = \\begin{pmatrix} \\frac{\\partial}{\\partial\\theta_0}MSE(\\bm\\theta) \\newline \\frac{\\partial}{\\partial\\theta_1}MSE(\\bm\\theta) \\newline \\vdots \\newline \\frac{\\partial}{\\partial\\theta_n}MSE(\\bm\\theta) \\newline \\end{pmatrix} = \\frac{2}{m} \\textbf X^T (\\textbf X \\bm\\theta - \\bm y) $$\nNotice that this formula involves calculations over the full training set $\\textbf X$, at each Gradient Descent step! As a result it is terribly slow on very large training sets. However, Gradient Descent scales well with the number of features; training a Linear Regression model when there are hundreds of thousands of features is much fast using Gradient Descent than using the Normal Equation or SVD decomposition.\nOnce you have the gradient vector, which increase the MSE, just go in the opposite direction. That means subtracting $\\nabla_{\\bm\\theta} MSE(\\bm\\theta)$ from $\\bm\\theta$. This is where the learning rate $\\eta$ comes in to plays: multiply the gradient vector by $\\eta$ to determine the size of the downhill step.\n$$ \\bm\\theta^{\\text{(next step)}} = \\bm\\theta - \\eta \\nabla_{\\bm\\theta} MSE(\\bm\\theta) $$\nLet\u0026rsquo;s look at a quick implementation of this algorithm.\neta = 0.1 n_iteration = 1000 m = 100 theta = np.random.randn(2, 1) for iteration in range(n_iteration): gradients = 2/m * X_b.T @ (X_b @ theta - y) theta -= eta * gradients That wasn\u0026rsquo;t too hard! Let\u0026rsquo;s take a look at the resulting $\\bm\\theta$\n\u0026gt;\u0026gt;\u0026gt; theta array([[5.09647054], [4.01624421]]) That\u0026rsquo;s exactly what the Normal Equation found! But what if you have used a different learning rates $\\eta$?\nOn the left the learning rate is too low: the algorithm will eventually reach the solution, but it will take a long time. On the right the learning rate is too high: the algorithm diverges, jumping all over the place and actually getting further and further away from the solution at every step. In the middle, the learning rate looks pretty good: in just a few iterations, it has already converged to the solution.\nConclution Linear Regression is an algorithm that every Data Scientist and Machine Learning engineer must know. It is also a good place to start for people who want to get into the Machine Learning industry as well. It is really a simple but useful algorithm.\nIn this post we have learnt about the concepts of linear regression and gradient descent. We also had a deep dive into the mathematics behind it as well as implemented the model from scratch using only NumPy. I hope you had as much fun reading as I did writing it.\nThank you for reading!\n","permalink":"https://nguyentritai.tk/posts/2020/linear-regression/","summary":"Linear Regression is the most basic, well known and well understood supervised learning algorithm. It\u0026rsquo;s probably the first thing that every Machine Learning Engineer and Data Scientist come across as it lays the foundation for other sophisticated learning algorithm. But what is it?\nWhat is Linear Regression? Before knowing what is linear regression, let us get ourselves accustomed to regression. Regression is a method of modeling the relationships between a dependent variable and one or more independent variables.","title":"Linear Regression and a deep dive into the mathematics behind it."},{"content":"Who am I \u0026hellip;\nThings I like \u0026hellip;\nHow to contact \u0026hellip;\n","permalink":"https://nguyentritai.tk/about/","summary":"Who am I \u0026hellip;\nThings I like \u0026hellip;\nHow to contact \u0026hellip;","title":""}]